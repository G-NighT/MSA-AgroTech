@startuml C4-alt-core

left to right direction

title C4 — Код: Incident Service (Core: Платформа мониторинга, Cloud-first)

' Контроллер/хендлеры
class IncidentController <<REST/gRPC endpoints>> {
  +createIncident(req: CreateIncidentDto): IncidentDto
  +confirmIncident(id: UUID, req: ConfirmDto): IncidentDto
  +getIncident(id: UUID): IncidentDto
  +searchIncidents(q: IncidentQuery): IncidentPage
  +acknowledge(id: UUID, by: UUID): IncidentDto
  +resolve(id: UUID, req: ResolveDto): IncidentDto
}

class InferenceResultHandler <<EventBus consumer>> {
  -subscription: "inference.results"
  +onMessage(evt: InferenceResultEvent): void
}

' Домен
class IncidentService <<domain>> {
  -repo: IIncidentRepository
  -publisher: IEventPublisher
  -orchestrator: IDeviceOrchestratorPort
  -notif: NotificationClient
  -media: MediaClient
  -config: ConfigClient
  -workflow: IncidentWorkflow
  +handleCreate(cmd: CreateIncidentCmd): Incident
  +handleConfirm(cmd: ConfirmIncidentCmd): Incident
  +handleResolve(cmd: ResolveIncidentCmd): Incident
  +handleAcknowledge(cmd: AckIncidentCmd): Incident
  +projectInference(evt: InferenceResultEvent): void
  +applySlaAndEscalation(inc: Incident, now: Instant): void
}

class IncidentWorkflow <<state/SLA>> {
  +next(current: Status, transition: Transition): Status
  +deadline(severity: Severity): Duration
  +shouldEscalate(inc: Incident, now: Instant): boolean
}

' Порты/адаптеры
interface IIncidentRepository {
  +save(inc: Incident): void
  +findById(id: UUID): Optional<Incident>
  +search(q: IncidentQuery): IncidentPage
  +appendOutbox(r: OutboxRecord): void
  +pullOutbox(batchSize: int): List<OutboxRecord>
}

class SqlIncidentRepository <<PostgreSQL>> {
  -ds: DataSource
  -tableInc: "incidents"
  -tableOutbox: "outbox"
  +save(inc: Incident): void
  +findById(id: UUID): Optional<Incident>
  +search(q: IncidentQuery): IncidentPage
  +appendOutbox(r: OutboxRecord): void
  +pullOutbox(batchSize: int): List<OutboxRecord>
}

interface IEventPublisher {
  +publish(evt: DomainEvent, topic: String): void
  +publishBatch(evts: List<DomainEvent>, topic: String): void
}

class EventBusPublisher <<pub/sub producer>> {
  -bus: EventBusClient
  -topicIncidents: "incidents.events"
  +publish(evt: DomainEvent, topic: String): void
  +publishBatch(evts: List<DomainEvent>, topic: String): void
}

interface IDeviceOrchestratorPort {
  +startAction(cmd: DeviceCommand): CommandId
  +getActionStatus(id: CommandId): DeviceCommandStatus
}

class DeviceOrchestratorClient <<adapter>> {
  -endpoint: URL
  +startAction(cmd: DeviceCommand): CommandId
  +getActionStatus(id: CommandId): DeviceCommandStatus
}

class NotificationClient <<HTTPS/WebPush>> {
  -endpoint: URL
  +send(to: Recipient, msg: Notification): void
  +escalate(to: OnCall, inc: Incident): void
}

class MediaClient <<S3 presign>> {
  -bucket: String
  +presignClip(uri: Uri, ttl: Duration): URL
  +presignFrame(uri: Uri, ttl: Duration): URL
}

class ConfigClient <<REST to Config Service>> {
  +thresholds(farmId: UUID, model: String): Thresholds
  +roi(cameraId: UUID): RegionOfInterest
  +featureEnabled(flag: String, farmId: UUID): boolean
}

' Модели/DTO/События/Команды
class Incident {
  +id: UUID
  +farmId: UUID
  +cameraId: UUID
  +type: String
  +severity: Severity
  +status: Status
  +startedAt: Instant
  +ackBy: UUID
  +confirmedBy: UUID
  +resolvedAt: Instant
  +clipUri: Uri
  +meta: Map<String,String>
}

class OutboxRecord {
  +id: UUID
  +type: String
  +payload: byte[]
  +createdAt: Instant
}

class Dto <<DTO>> {
  +CreateIncidentDto
  +IncidentDto
  +ConfirmDto
  +ResolveDto
  +IncidentQuery
  +IncidentPage
}

class Events <<DomainEvents>> {
  +IncidentCreated(id: UUID, severity: Severity, clip: Uri)
  +IncidentAcknowledged(id: UUID, by: UUID, at: Instant)
  +IncidentConfirmed(id: UUID, by: UUID, at: Instant)
  +IncidentResolved(id: UUID, reason: String)
}

class InferenceResultEvent {
  +cameraId: UUID
  +farmId: UUID
  +model: String
  +class: String
  +score: float
  +frameUri: Uri
  +ts: Instant
}

class Commands <<DeviceCommands>> {
  +OpenFeeder(id: DeviceId, duration: Seconds)
  +CloseFeeder(id: DeviceId)
  +IncreaseWaterFlow(id: DeviceId, delta: int)
  +AlarmSiren(zone: String, duration: Seconds)
}

' Связи
IncidentController --> IncidentService : команды/запросы
InferenceResultHandler --> IncidentService : projectInference(evt)

IncidentService --> IIncidentRepository : persist/query
SqlIncidentRepository -up-|> IIncidentRepository

IncidentService --> IEventPublisher : publish domain events
EventBusPublisher -up-|> IEventPublisher

IncidentService --> IDeviceOrchestratorPort : управляющие команды
DeviceOrchestratorClient -up-|> IDeviceOrchestratorPort

IncidentService --> NotificationClient : уведомления/эскалации
IncidentService --> MediaClient : presign links
IncidentService --> ConfigClient : thresholds/roi/features
IncidentService --> IncidentWorkflow : переходы/SLA

' Зависимостные связи на модели/DTO/Events/Commands
IncidentController ..> Dto : uses
InferenceResultHandler ..> InferenceResultEvent : consumes
IncidentService ..> Incident : manipulates
IncidentService ..> Events : raises
IIncidentRepository ..> Incident : persists
SqlIncidentRepository ..> OutboxRecord : outbox
IEventPublisher ..> Events : publishes
IDeviceOrchestratorPort ..> Commands : executes

' Примечания
note right of IncidentWorkflow
  Status: NEW, ACKED, CONFIRMED, RESOLVED
  Severity: LOW/MEDIUM/HIGH/CRITICAL
  Transition: {ack, confirm, resolve, auto_close}
end note

@enduml
